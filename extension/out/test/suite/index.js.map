{
  "version": 3,
  "sources": ["../../../src/test/suite/index.ts", "../../../src/test/suite/rust.test.ts"],
  "sourcesContent": ["import { runRustIntegrationTest } from \"./rust.test\";\n\n// VS Code test runner entrypoint (referenced by @vscode/test-electron).\n// Keep this minimal and avoid extra dependencies (no mocha/glob required).\nexport async function run(): Promise<void> {\n  await runRustIntegrationTest();\n}\n", "import * as assert from \"node:assert\";\nimport * as vscode from \"vscode\";\n\ntype AnvilHoloApi = {\n  spawnSlicerMap?: (...args: any[]) => Promise<any>;\n};\n\nexport async function runRustIntegrationTest(): Promise<void> {\n  const extId = \"devshero.anvil-holo\";\n  const ext = vscode.extensions.getExtension<AnvilHoloApi>(extId);\n  assert.ok(ext, `Expected extension ${extId} to be installed in test host`);\n\n  // Activate without opening UI.\n  const api = (await ext!.activate()) as AnvilHoloApi;\n  assert.ok(api && typeof api.spawnSlicerMap === \"function\", \"Expected extension to export spawnSlicerMap API\");\n\n  // OutputChannel-like sink that prints to the test runner console.\n  const out = {\n    appendLine: (line: string) => console.log(String(line).replace(/\\n$/, \"\"))\n  } as any;\n\n    const folder = vscode.workspace.workspaceFolders?.[0];\n    assert.ok(folder, \"Expected a workspace folder to be open in the test host\");\n\n    // Prefer a small manifest so the test stays fast/stable.\n    const candidates = [\"core/Cargo.toml\", \"package.json\"];\n    let manifest = candidates[candidates.length - 1];\n    for (const c of candidates) {\n      try {\n        await vscode.workspace.fs.stat(vscode.Uri.joinPath(folder!.uri, c));\n        manifest = c;\n        break;\n      } catch {\n        // continue\n      }\n    }\n\n    console.log(`[test] Calling spawnSlicerMap with --manifests ${manifest}`);\n\n  // spawnSlicerMap(extensionUri, outputChannel, targetPath, mode, manifests)\n  let map: any;\n  try {\n      map = await api.spawnSlicerMap!(ext!.extensionUri, out, undefined, \"module-network\", [manifest]);\n    console.log(\"[test] Rust JSON (raw):\\n\" + JSON.stringify(map, null, 2));\n  } catch (e: any) {\n    console.error(\"[test] spawnSlicerMap threw:\", e?.message || String(e));\n    throw e;\n  }\n\n  const nodesLen = Array.isArray(map?.nodes) ? map.nodes.length : 0;\n  console.log(\"[test] nodes=\", nodesLen, \"edges=\", Array.isArray(map?.edges) ? map.edges.length : 0);\n  assert.ok(nodesLen > 0, \"Expected module graph nodes.length > 0 (Rust returned empty graph)\");\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,aAAwB;AACxB,aAAwB;AAMxB,eAAsB,yBAAwC;AAC5D,QAAM,QAAQ;AACd,QAAM,MAAa,kBAAW,aAA2B,KAAK;AAC9D,EAAO,UAAG,KAAK,sBAAsB,KAAK,+BAA+B;AAGzE,QAAM,MAAO,MAAM,IAAK,SAAS;AACjC,EAAO,UAAG,OAAO,OAAO,IAAI,mBAAmB,YAAY,iDAAiD;AAG5G,QAAM,MAAM;AAAA,IACV,YAAY,CAAC,SAAiB,QAAQ,IAAI,OAAO,IAAI,EAAE,QAAQ,OAAO,EAAE,CAAC;AAAA,EAC3E;AAEE,QAAM,SAAgB,iBAAU,mBAAmB,CAAC;AACpD,EAAO,UAAG,QAAQ,yDAAyD;AAG3E,QAAM,aAAa,CAAC,mBAAmB,cAAc;AACrD,MAAI,WAAW,WAAW,WAAW,SAAS,CAAC;AAC/C,aAAW,KAAK,YAAY;AAC1B,QAAI;AACF,YAAa,iBAAU,GAAG,KAAY,WAAI,SAAS,OAAQ,KAAK,CAAC,CAAC;AAClE,iBAAW;AACX;AAAA,IACF,QAAQ;AAAA,IAER;AAAA,EACF;AAEA,UAAQ,IAAI,kDAAkD,QAAQ,EAAE;AAG1E,MAAI;AACJ,MAAI;AACA,UAAM,MAAM,IAAI,eAAgB,IAAK,cAAc,KAAK,QAAW,kBAAkB,CAAC,QAAQ,CAAC;AACjG,YAAQ,IAAI,8BAA8B,KAAK,UAAU,KAAK,MAAM,CAAC,CAAC;AAAA,EACxE,SAAS,GAAQ;AACf,YAAQ,MAAM,gCAAgC,GAAG,WAAW,OAAO,CAAC,CAAC;AACrE,UAAM;AAAA,EACR;AAEA,QAAM,WAAW,MAAM,QAAQ,KAAK,KAAK,IAAI,IAAI,MAAM,SAAS;AAChE,UAAQ,IAAI,iBAAiB,UAAU,UAAU,MAAM,QAAQ,KAAK,KAAK,IAAI,IAAI,MAAM,SAAS,CAAC;AACjG,EAAO,UAAG,WAAW,GAAG,oEAAoE;AAC9F;;;ADhDA,eAAsB,MAAqB;AACzC,QAAM,uBAAuB;AAC/B;",
  "names": []
}
